var path = Npm.require('path');
var sass = Npm.require('node-sass');
var fs   = Npm.require('fs');
var _    = Npm.require('lodash');

var autoprefixer = Npm.require('autoprefixer-core');

var generatedIndexMessage = [
  "// This file is auto generated by the scss package",
  "// New .scss and .sass files will be automatically '@import'ed  at the bottom",
  "// Existing content in the file will not be touched",
  "// When deleting a .scss or .sass file you must manually delete it from here",
  "",
  ""
].join("\n");

var CONFIG_FILE_NAME = 'scss.json';
var ASSETS_PACKAGES = '.meteor/local/build/programs/server/assets/packages/';

var projectTopDir = process.cwd();
var projectOptionsFile = path.resolve(projectTopDir, CONFIG_FILE_NAME);
var projectOptionsFile2 = path.resolve(projectTopDir, '.meteor', CONFIG_FILE_NAME);

var loadJSONFile = function (filePath) {
  var content = fs.readFileSync(filePath);
  try {
    return JSON.parse(content);
  }
  catch (e) {
    console.log("Error: failed to parse ", filePath, " as JSON");
    return {};
  }
};

var repairScssOptions = function(options) {
  if (options['imports']) {
    var imports = options.imports.map(function(packageName) {
      return path.join(ASSETS_PACKAGES, packageName.replace(':', '_'));
    });
    options['includePaths'] = _.merge({}, options['includePaths'], imports);
    delete options['imports'];
  }
};

var sourceHandler = function(compileStep) {
  // Don't process partials
  if ( path.basename(compileStep.inputPath)[0] === '_' )
    return;
  // XXX annoying that this is replicated in .css, .less, and .styl
  var basePath = compileStep.fullInputPath.slice(0, -compileStep.inputPath.length);
  // If a package has a scss.json file this takes precedence.
  var packageOptionsFile = path.resolve(basePath, CONFIG_FILE_NAME);

  var scssOptions = {};

  if (fs.existsSync(packageOptionsFile)) {
    scssOptions = loadJSONFile(packageOptionsFile);
  } else if (fs.existsSync(projectOptionsFile)) {
    scssOptions = loadJSONFile(projectOptionsFile);
  } else if (fs.existsSync(projectOptionsFile2)) {
    scssOptions = loadJSONFile(projectOptionsFile2);
  } else if (compileStep.fileOptions && compileStep.fileOptions.testOptions) {
    scssOptions = compileStep.fileOptions.testOptions;
  }

  repairScssOptions(scssOptions);

  if ( scssOptions.useIndex ) {
    var indexFilePath = scssOptions.indexFilePath || "index.scss";
    // Swap the input path (from windows \ to unix / - since node-sass seems to prefer it)
    // This should probably be through a path method, but no one uses the \ slash in a .scss file,
    // Which is what would be outputted to the indexFilePath if it was done via path.normalize.
    var normalizedPath = compileStep.inputPath.replace(/\\/g, "/");
    // If this isn't the index file, add it to the index if need be
    if ( normalizedPath != indexFilePath ) {
      if ( fs.existsSync(indexFilePath) ) {
        var scssIndex = fs.readFileSync(indexFilePath, 'utf8');
        if (scssIndex.indexOf(normalizedPath) == -1) {
          fs.appendFileSync(indexFilePath, '\n@import "' + normalizedPath + '";', 'utf8');
        }
      } else {
        var newFile = generatedIndexMessage + '@import "' + normalizedPath + '";\n';
        fs.writeFileSync(indexFilePath, newFile, 'utf8');
      }
      return; // stop here, only compile the indexFile
    }
  }

  var options = _.extend({
    sourceMap:         true,
    // These are the magic incantations for sass sourcemaps
    sourceMapContents: true,
    sourceMapEmbed:    true,
    outFile:           compileStep.pathForSourceMap,
    includePaths:      []
  }, scssOptions);

  options.file  = compileStep.fullInputPath;

  if ( !_.isArray(options.includePaths) ) {
    options.includePaths = [options.includePaths];
  }

  // Convert relative paths supplied via the options file to absolute paths.
  options.includePaths = _.map(options.includePaths, function(includePath) {
    return path.resolve(basePath, includePath);
  });

  options.includePaths = options.includePaths.concat(path.dirname(compileStep.fullInputPath));

  var result;
  try {
    result = sass.renderSync(options);
  } catch (error) {
    return compileStep.error({
      message: "Scss compiler error: " + error.message + "\n",
      sourcePath: error.file || compileStep.inputPath,
      line: error.line,
      column: error.column
    });
  }

  if ( options.enableAutoprefixer) {
    var autoprefixerOptions = options.autoprefixerOptions || {}
    var autoprefixerProcessingOptions = {
      from: compileStep.inputPath,
      to: compileStep.inputPath + ".css",
      map: true
    };
    try {
      // Applying Autoprefixer to compiled css
      var processor      = autoprefixer(autoprefixerOptions);
      var prefixedOutput = processor.process(result.css, autoprefixerProcessingOptions);
      result.css         = prefixedOutput.css;
    } catch (e) {
      compileStep.error({
        message: "Autoprefixer error: " + e,
        sourcePath: e.filename || compileStep.inputPath
      });
    }
  }
  compileStep.addStylesheet({
    path: compileStep.inputPath + ".css",
    data: result.css.toString()
  });
};

Plugin.registerSourceHandler("scss", {archMatching: 'web'}, sourceHandler);
Plugin.registerSourceHandler("sass", {archMatching: 'web'}, sourceHandler);

Plugin.registerSourceHandler("scssimport", function () {
  // Do nothing
});
